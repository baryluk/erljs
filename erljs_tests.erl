-module(erljs_tests).

-export([c/1]).

-spec c(atom()) -> {'ok', string(), [{_,_}, ...]}.

c(Module) when is_atom(Module) ->
	Modulename = atom_to_list(Module),
	Filename = Modulename,
	{ok, File} = file:open(Filename, [read, {read_ahead, 8192}]),
	{ok, FileErl} = file:open(Modulename ++ ".erl", [write]),
	{ok, FileJS} = file:open(Modulename ++ ".js", [write]),
	ok = file:write(FileErl, ["% This file was automatically generated by erljs_tests from ", Modulename, " tests specification\n"]),
	ok = file:write(FileErl, ["-module('", Modulename, "').\n"]),
	ok = file:write(FileErl, "-compile([export_all]).\n"),
	ok = file:write(FileJS, ["// This file was automatically generated by erljs_tests from ", Modulename, " tests specification\n"]),
	ok = file:write(FileJS, ["function ", "unittest__", Modulename, "() {\n"]),
	io:format("Processing lines"),
	Stats = {0,0,0},
	process(file:read_line(File), File, [], 1, Stats, {Modulename, FileErl, FileJS}).

-spec process(
		'eof' | {'ok',string()},
		pid() | {'file_descriptor', atom(), _},
		[{[any()],_}],
		pos_integer(),
		{non_neg_integer(), non_neg_integer(), non_neg_integer()},
		{string(), pid() | {'file_descriptor', atom(), _}, pid() | {'file_descriptor', atom(), _}}
	) ->
		{'ok', string(), [{_,_}, ...]}.

process(eof, File, _Code, _LineNo, Stats = {StatsWithWrapper, StatsWithTerm, StatsWithCall}, {Modulename, FileErl, FileJS}) ->
	io:format("~n"),
	ok = file:close(File),
	ok = file:close(FileErl),
	ok = file:write(FileJS, "\treturn true;\n}\n"),
	ok = file:close(FileJS),
	{ok, _OutputFile, _Stats} = erljs:c(Modulename),
	{ok, Modulename, [
		{direct_call, StatsWithCall},
		{wrapper, StatsWithWrapper},
		{term, StatsWithTerm},
		{total, StatsWithCall+StatsWithWrapper+StatsWithTerm}
	]};
process({ok, Line0}, File, Code, LineNo, Stats, Aux = {Modulename, FileErl, FileJS}) ->
	Line1 = string:strip(Line0, both),
	Line2 = string:strip(Line1, both, $\t),
	Line = string:strip(Line2, right, $\n),
	io:format(" ~p", [LineNo]),
	%io:format("Processing lines", [LineNo]),
	%io:format("~p~n", [Line]),
	CodeLine = case Line of
		[] -> Line;
		_ -> case hd(Line) of
			$% -> []; % strip comments
			_ -> Line
		end
	end,
	{NewCode,NewStats} = case CodeLine of
		[] ->
			{Code,Stats};
		_ ->
			{ok, Tokens, _LastLocation} = erl_scan:string(Line),
			%io:format("tokenized~n"),
			{ok, [AbstractExpression]} = erl_parse:parse_exprs(Tokens),
			%io:format("parsed~n"),
			Bindings = erl_eval:new_bindings(),
			{value, Value0, _NewBindings} = erl_eval:expr(AbstractExpression, Bindings),
			% handled exception to only contain one element in stack trace
			% TODO: discover automatically what amount of stack trace entries to keep
			Value = case Value0 of
				{'EXIT',{ExceptionReason,[ExceptionStackTraceFirst|_ExceptionStackTraceRest]}} ->
					{'EXIT',{ExceptionReason,[ExceptionStackTraceFirst]}};
				_ -> Value0
			end,
			%io:format("evalueted~n"),
			%io:format("~p~n", [Value]),
			Type = case Line of
				[$e,$r,$l,$a,$n,$g,$:|_] -> wrapper;
				[$m,$a,$t,$h,$:|_] -> wrapper;
				[$b,$e,$g,$i,$n|_] -> wrapper;
				[$c,$a,$t,$c,$h|_] -> wrapper;
				[$(| _] -> term;
				[Letter|_] when is_integer(Letter), $A =< Letter, Letter =< $Z -> wrapper;
				_ -> call
			end,
			Stats2 = case Type of
				wrapper ->
					% more complicated expressions or complicated function calls
					% prepare temporary function for it and compile
					%io:format(FileErl, "test_~w() -> ~s~n", [LineNo, Line]),
					file:write(FileErl, ["test_", integer_to_list(LineNo) ,"() ->\n\t",
						Line, "\n"]),
					%io:format("eq(\"test_~w()\", \"~s\");~n", [LineNo, lists:flatten(io_lib:write(Value))]);
					file:write(FileJS, ["\teq(\"", Modulename, ":test_", integer_to_list(LineNo) ,"()", "\",\n\t\t",
						io_lib:write_string(lists:flatten(io_lib:print(Value,1,1000000000000,-1))), ",\n\t\t",
						io_lib:write_string(Line), ");\n"]),
					setelement(1, Stats, element(1, Stats)+1);
				term ->
					io:format(FileJS, "d2(\"~s\", \"~s\");~n", [Line, lists:flatten(io_lib:write(Value))]),
					setelement(2, Stats, element(2, Stats)+1);
				call ->
					% simple function calls
					file:write(FileJS, ["\teq(", io_lib:write_string(Line), ",\n\t\t",
						io_lib:write_string(lists:flatten(io_lib:print(Value,1,1000000000000,-1))), ");\n"]),
					setelement(3, Stats, element(3, Stats)+1)
			end,
			{[{Line, Value}|Code], Stats2}
	end,
	process(file:read_line(File), File, NewCode, LineNo+1, NewStats, Aux).


%erl_scan:reserved_word(Atom) - bool
%erl_parse:parse_term(Tokens) -> {ok, Term}
%{ok, ParsedLine} = io:parse_erl_form(Line, ),


