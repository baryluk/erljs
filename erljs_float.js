/* Witold Baryluk, 2011-06-13 */

inv_pow_2_table = [];

(function /*inv_pow_2_table_init*/ () {
	for (i = 0; i < 2048; i++) {
		inv_pow_2_table[i] = Math.pow(2.0, i-1023);
	}
})();

pow2_m52 = Math.pow(2, -52); // 2.2204460492503131e-16

// all arguments are bytes, an integers in range 0-255 exclusive.
// function returns double precision floating point number coresponding to a...h bytes, using IEEE754 standard
function bytes_to_float(a,b,c,d,e,f,g,h) {
	var S = (a & 0x80);
	var E = ((a & 0x7f) << 4) | ((b & 0xf0) >> 4); //     (b >> 4) should suffice actually.
	var Fu = (b & 0x0f) << 16 | (c << 8) | d;
	//var Fd = (e << 24) | (f << 16) | (g << 8) | h; // can overflow over signed integer :(
	//var Fd = e*16777216 + f*65536 + g*256 + h;
	var Fd = e*16777216 + ((f<<16) | (g<<8) | h);
	var x;
	if (E == 0) {
		if (Fu == 0 && Fd == 0) {
			x = 0.0; // zero
		} else {
			x = 4294967296*Fu + Fd;
			x *= pow2_m52;
			x += 1.0;
			x *= inv_pow_2_table[E];
		}
	} else if (E == 0x7ff) {
		if (Fu == 0 && Fd == 0) {
			x = Infinity;
		} else {
			x = NaN; // it should be NaN with payload, but we can assume it isn't, as Erlang isn't using it
		}
	} else {
		//x = (Fu << 32) | Fd; // can overflow over signed integer :(
		x = 4294967296*Fu + Fd;
		x *= pow2_m52;
		x += 1.0;
		x *= inv_pow_2_table[E];
	}
	return (S ? -x : x);
}

function bytes_to_float_test_() {
	//inv_pow_2_table_init();

	function isnan(x) {
		return !(x == x);
	}

	var results = [
		bytes_to_float(0x7f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00) == Infinity,
		bytes_to_float(0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00) == -Infinity,
		1.0 / bytes_to_float(0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00) == Infinity,
		1.0 / bytes_to_float(0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00) == -Infinity,

		bytes_to_float(0x7f,0xe0,0x00,0x00,0x00,0x00,0x00,0x00) == 8.98846567431158e+307,
		bytes_to_float(0x7f,0xef,0xff,0xff,0xff,0xff,0xff,0xff) == 1.7976931348623157e+308,
		bytes_to_float(0xff,0xef,0xff,0xff,0xff,0xff,0xff,0xff) == -1.7976931348623157e+308,
		bytes_to_float(0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00) == -8.98846567431158e+307,

		bytes_to_float(0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00) == 0,
		bytes_to_float(0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00) == 2.2250738585072014e-308,
		bytes_to_float(0x80,0x10,0x00,0x00,0x00,0x00,0x00,0x00) == -2.2250738585072014e-308,
		bytes_to_float(0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00) == 2,
		bytes_to_float(0x40,0x10,0x00,0x00,0x00,0x00,0x00,0x00) == 4,
		bytes_to_float(0x3f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00) == 1,
		bytes_to_float(0xbf,0xf0,0x00,0x00,0x00,0x00,0x00,0x00) == -1,
		bytes_to_float(0x3f,0xe0,0x00,0x00,0x00,0x00,0x00,0x00) == 0.5,
		bytes_to_float(0xbf,0xe0,0x00,0x00,0x00,0x00,0x00,0x00) == -0.5,
		bytes_to_float(0x3f,0xe5,0x2c,0xae,0x3a,0x0f,0xf8,0x3a) == 0.6617041715651404,

		isnan(bytes_to_float(0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff)),
		isnan(bytes_to_float(0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff)),
		isnan(bytes_to_float(0x7f,0xf0,0x00,0x00,0x00,0x55,0x00,0x00)),
		isnan(bytes_to_float(0xff,0xf0,0x00,0x00,0x00,0x55,0x00,0x00)),

		// denormals
		/*
		bytes_to_float(0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01) == ,
		bytes_to_float(0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01) == ,
		bytes_to_float(0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01) == ,
		bytes_to_float(0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00) == ,
		bytes_to_float(0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00) == ,
		bytes_to_float(0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff) == ,
		bytes_to_float(0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xfe) == ,
		*/

		// using C and Python
		bytes_to_float(0x40,0x0f,0xff,0xff,0xff,0xff,0xff,0x00) == 3.9999999999998863,
		bytes_to_float(0x40,0x0f,0xff,0xfe,0xff,0xff,0xff,0x00) == 3.9999980926512535,
		bytes_to_float(0x40,0x0f,0xff,0xff,0xff,0xff,0xff,0xf0) == 3.999999999999993,
		bytes_to_float(0x40,0x0f,0xff,0xff,0xff,0xff,0xff,0xfe) == 3.999999999999999,
		bytes_to_float(0x40,0x0f,0xff,0xff,0xff,0xff,0xff,0xff) == 3.9999999999999996,
		bytes_to_float(0x3f,0xff,0xff,0xff,0xff,0xff,0xfe,0x1e) == 1.999999999999893,
		bytes_to_float(0x3f,0xff,0xff,0xff,0xff,0xff,0xff,0xfe) == 1.9999999999999996,
		bytes_to_float(0x3f,0xe5,0x2c,0xae,0x3a,0x0f,0xf8,0x3a) == 0.6617041715651404,
		bytes_to_float(0x3f,0xdf,0xff,0xff,0x5d,0x5d,0xf0,0x7e) == 0.49999984853616997,
		bytes_to_float(0x3f,0xc8,0x06,0x0f,0xbd,0x39,0xae,0xa9) == 0.187684981723,

		// python> Math.pi.hex() == '0x1.921fb54442d18p+1'
		bytes_to_float(0x40,0x09,0x21,0xfb,0x54,0x44,0x2d,0x18) == 3.1415926535897931,
		bytes_to_float(0x3f,0xd3,0x33,0x33,0x33,0x33,0x33,0x33) == 0.3,
		bytes_to_float(0x3f,0xf4,0xcc,0xcc,0xcc,0xcc,0xcc,0xcd) == 1.3,
		bytes_to_float(0x3f,0xf8,0x00,0x00,0x00,0x00,0x00,0x00) == 1.5
	];

	return results;
}
